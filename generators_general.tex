\subsection{General Graphs}
\label{sec:generators_general}

We start by focusing on approaches that have been designed for dealing with the generation of general graph
data that is not aimed at a particular application domain. Currently, there exists a
number of tools which involve a kind of general graph data generator, such as
gtools from projects nauty and Traces~\cite{gtools} or the Stanford
GraphBase~\cite{GraphBase}. We, however, focus on primarily
generating/benchmarking projects targeting the Big Data world.


\paragraph {Preferential Attachment} Barabasi and Albert~\cite{Barabasi99emergenceScaling} introduced a graph generation model that relies on two main mechanisms. The first mechanism is continuously expanding the graphs by adding new vertices. The second mechanism is to preferentially attach the new vertices   to the nodes/regions that are already well connected. So, in this approach, the generation of large graphs is governed by standard, robust self-organizing mechanisms that go beyond the characteristics of individual applications.

\paragraph {R-MAT} R-MAT (\emph{R}ecursive \emph{Mat}rix) is a procedural synthetic graph generator which is designed to generate power-law degree
distributions~\cite{DBLP:conf/sdm/ChakrabartiZF04}.
The generator is recursive and employs a fairly small number of parameters.
In principle, the strategy of this generator is to achieve simple means to generate graphs that match
the properties of the real graphs. In particular, the design goals of R-MAT is to generate graphs that match the degree distributions, imitate a community structure and have a small diameter. R-MAT can generate weighted, directed and bipartite graphs.

\paragraph{GraphGen} For the purpose of testing the scalability of an indexing
technique called FG-index~\cite{Cheng:2007:FTV:1247480.1247574} on the size of the
database of graphs, their average size and average density, the authors have
also implemented a synthetic generator called
GraphGen\footnote{https://www.cse.ust.hk/graphgen/}. It relies on data generation code for associations and sequential
patterns provided by IBM\footnote{From 1996, no longer available at
\url{http://www.almaden.ibm.com/cs/projects/iis/hdb/Projects/data
mining/mining.shtml}}. GraphGen yields a collection of undirected, labeled and
connected graphs. It addresses the performance evaluation of frequent subgraph mining
algorithms and graph query processing algorithms. The result is represented as a
list of graphs, each consisting of a list of nodes along with a list of edges.


%\paragraph{Graph 500 Benchmark} The Graph 500 Benchmark~\cite{Graph500} includes
%a scalable data generator which produces weighted, undirected graph as a list of
%edge tuples containing the label of start vertex and end vertex together with a
%weight that represents data assigned to the edge. The space of vertex  labels is
%the set of integers beginning with 0. The input values required to describe the
%graph are (1) scale, i.e., the logarithm base two of the number of vertices, and
%(2) edge factor, i.e., the ratio of the graph's edge count to its vertex count
%(i.e., half the average degree of a vertex in the graph). The graph generator is
%a Kronecker generator similar to R-MAT. The data must not exhibit any locality,
%so in the final step the vertex labels and order of edges are randomly shuffled.
%The covered operations currently involve BFS; however, the authors intend to
%involve also two more types -- optimization (single source shortest path) and
%edge-oriented (maximal independent set) -- and five graph-related business areas:
%cybersecurity, medical informatics, data enrichment, social networks, and
%symbolic networks.

\paragraph{BTER} BTER (Block Two-Level
Erd\"{o}s-R\'{e}ny)~\cite{kolda2014scalable} is a graph generator based on the
creation of multiple Erd\"{o}s-R\'{e}ny graphs with different connection
probabilities  of which they are connected randomly between them. As the main feature, BTER is able
to reproduce input degree distributions and average clustering
coefficient per degree values. The generator starts by grouping the vertices
by degree $d$, and forming groups of size $d+1$ of nodes with degree $d$. Then, these
groups are assigned an internal edge probability in order to match the observed
average clustering coefficient of the nodes of such degree. Based on this
probability, for each node, the excess degree (i.e, the degree that in
expectation will not be realized internally in the group) is computed and used to connect
nodes from different groups at random. The authors describe a highly scalable
MapReduce based implementation that is capable of generating large graphs (with
billions of nodes) in a reasonable amounts of time.

\paragraph{Darwini} Darwini~\cite{edunov2016darwini} is an extension of BTER
designed to run on Vertex Centric computing frameworks like
Pregel~\cite{malewicz2010pregel} or Apache Giraph~\cite{ching2015one}, with the
additional feature that it is more accurate when reproducing the clustering
coefficient of the input graph. Instead of just focusing on the average
clustering coefficient for each degree, Darwini is able to model the clustering
coefficient distribution per degree. It achieves this by gathering the vertices
of the graph into buckets based on the expected number of closed triangles that they need
to close in order to attain the expected clustering coefficient. The latter is
sampled from the input distributions. Then, the vertices in each bucket are
connected randomly with a probability that would produce the expected
desired number of triangles for each bucket. Then, as in BTER, the excess degree
is used to connect the different buckets. The authors report that Darwini is
able to generate graphs with billions and even trillions of edges.

%\paragraph{gtools} Projects nauty and Traces~\cite{gtools} are programs for
%computing automorphism groups of graphs and digraphs~\cite{McKay201494}; they
%can also produce a canonical label. In the respective package there is also
%suite of programs called gtools which involve generators for non-isomorphic
%graphs, bipartite graphs, digraphs, and multigraphs.



