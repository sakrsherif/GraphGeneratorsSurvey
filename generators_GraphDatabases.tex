\subsection{Graph Databases}
\label{sec:generators_GraphDatabases}

Currently there exists a number  of papers which compare the efficiency of graph databases with regards to distinct use cases, such as  the community detection problem~\cite{Beis2015}, social tagging systems~\cite{Giatsoglou2011}, graph traversal~\cite{Ciglan:2012:BTO:2374486.2375242}, graph pattern matching~\cite{Pobiedina2014}, data provenance~\cite{Vicknair:2010:CGD:1900008.1900067}, or even several distinct use cases~\cite{Grossniklaus2013Towar-24253}. However, the number of graph data generators and benchmarks that have been designed specifically for graph databases is relatively small. Either a general graph generator is used for benchmarking graph databases, such as, e.g., the HPC Scalable Graph Analysis Benchmark~\cite{Dominguez-Sal:2010:SGD:1927585.1927590} or the graph DBMS benchmarking tools are designed in a more general scope. Hence it is questionable whether a benchmark  that is targeted specifically for graph databases is necessary. \cite{Dominguez-Sal:2010:DDG:1946050.1946053} discussed this question and related topics. On the basis of a review of applications of graph databases (namely, social network analysis,  genetic interactions, recommendation systems, and travel planning and routing), the authors analyzed and discussed the features of the graphs for these types of applications and how they could affect the benchmarking process, different types of operations used in these applications and the characteristics of the evaluation setup of the benchmark. In this section, we focus on graph data generators and benchmarks that have been primarily targeting graph DBMSs.


\paragraph{XGDBench} XGDBench~\cite{Dayarathna:2014:GDB:2676904.2676939} is an extensible  benchmarking platform for graph databases used in cloud-based systems. Its intent is to automate
the process of graph database benchmarking in the cloud by focusing on the domain social networking services. It extends the Yahoo! Cloud Multiplicative Attribute (MAG) Graph Serving Benchmark (YCSB)~\cite{Cooper:2010:BCS:1807128.1807152} and provides a set of standard workloads representing various performance issues. In particular, the workload of XGDBench involves basic operations such as read / insert / update / delete an attribute, loading of the list of neighbors and BFS traversal. Using the generators, 7 workloads are created, such as update heavy, read mostly, short range scan, traverse heavy etc.
The data model of XGDBench is a simplified version of the Multiplicative Attribute Graph (MAG)~\cite{Kim2010} model, a synthetic graph model which models the interactions between  node attributes and  graph structure.
The generated graphs are thus in MAG format, with power-law degree distribution closely simulating real-world social networks.
The simplified MAG algorithm accepts the required number of nodes, the number of attributes per each node, a threshold value for random attribute initialization, an edge affinity threshold determining existence of an edge between two nodes, and an affinity matrix. \iffalse It has been proven that MAG generates graphs with both analytically tractable and statistically interesting properties.\fi 
Large graphs can be generated on multi-core systems by a multi-threaded version of the  generator.


\paragraph{gMark}  gMark~\cite{gMark} is a schema-driven and domain-agnostic generator of both graph instances and graph query workloads. It can generate instances under the form of N-triples and queries in various concrete query languages, including OpenCypher\footnote{\url{https://neo4j.com/developer/cypher-query-language/}}, recursive SQL, SPARQL and LogicQL. In gMark, it is possible to specify a \emph{graph configuration} involving the admitted edge predicates and node labels occurring in the graph instance along with additional parameters such as degree distribution, occurrence constraints, etc. The \emph{Query workload configuration} describes parameters of the query workload to be generated, by including the number of queries, arity, shape and selectivity of the queries.
The problem of deciding whether there exists a graph that satisfies a defined graph specification $G$ is NP-complete. The same applies to the problem of deciding
whether there exists a query workload compliant with a given query workload configuration $Q$. In view of this, gMark adopts a best effort approach in which the
parameters specified in the configuration files are attained in a relaxed fashion in order to achieve linear running time whenever possible.

%The authors prove that deciding whether there exists a graph satisfying a given graph configuration $G$ is NP-complete. And, similarly, deciding
%whether there exists a query workload satisfying a given query workload configuration $Q$ is also NP-complete. Hence, gMark generating is based on a heuristic strategy: it tries to achieve the exact values of the given parameters, however, in order to obtain linear running time it may decide to relax some. gMark generates graphs under the form of N-triples and query workloads in four concrete syntaxes, including Cypher\footnote{\url{https://neo4j.com/developer/cypher-query-language/}}, SPARQL, SQL and LogicQL.

\paragraph{GraphGen}  GraphAware GraphGen\footnote{\url{http://graphgen.graphaware.com/}} is a graph generation engine based on Neo4j's\footnote{\url{https://neo4j.com/}} query language Cypher~\cite{GraphGen}.  It creates nodes and relationships based on a schema definition expressed in Cypher, and it can also generate property values on both
nodes and edges. As such, GraphGen is a precursor of property graphs generators. The resulting graph can be exported to several formats (namely GraphJson\footnote{\url{https://github.com/GraphAlchemist/GraphJSON/wiki/GraphJSON}} and CypherQueries) or loaded directly to a DBMS. However, it is very likely that it is not maintained anymore due to the lack of available updates.
