\subsection{Graph Databases}
\label{sec:generators_GraphDatabases}

Currently there exists a number  of papers which compare the efficiency of graph databases with regards to distinct use cases, such as  the community detection problem~\cite{Beis2015}, social tagging systems~\cite{Giatsoglou2011}, graph traversal~\cite{Ciglan:2012:BTO:2374486.2375242}, graph pattern matching~\cite{Pobiedina2014}, data provenance~\cite{Vicknair:2010:CGD:1900008.1900067}, or even several distinct use cases~\cite{Grossniklaus2013Towar-24253}. However, the number of graph data generators and benchmarks designed particularly for graph databases is relatively small. Either a general graph generator is used for benchmarking graph databases, such as, e.g., the HPC Scalable Graph Analysis Benchmark~\cite{Dominguez-Sal:2010:SGD:1927585.1927590}. Or the graph DBMS benchmarking tools are designed in a more general scope. Hence it is questionable whether a benchmark specific for graph databases is necessary. \cite{Dominguez-Sal:2010:DDG:1946050.1946053} discussed this question and related topics. On the basis of a review of applications of graph databases (namely social network analysis, proteomics or genetic interactions, recommendation systems, and travel planning and routing), the authors analyze and discuss the characteristics of the graphs that appear in such applications and how they could influence benchmarking, different types of operations used in these applications and the characteristics of the evaluation setup of the benchmark. In this section, we focus on graph data generators and benchmarks that have been primarily targeting graph DBMSs.


\paragraph{XGDBench} XGDBench~\cite{Dayarathna:2014:GDB:2676904.2676939} is an extensible graph database benchmarking platform for cloud computing systems. Its intent is to automate
the process of graph database benchmarking in the cloud focusing on a graph database application for social networking services. It extends the Yahoo! Cloud Multiplicative Attribute (MAG) Graph Serving Benchmark (YCSB)~\cite{Cooper:2010:BCS:1807128.1807152} and is composed of a workload generator client and a package of standard workloads that cover interesting parts of the performance space.
The workload generator of YCSB supports definition of new workload types. XGDBench involves basic operations read / insert / update / delete an attribute, loading of the list of neighbors and BFS traversal. Using them 7 workloads are created, such as update heavy, read mostly, short range scan, traverse heavy etc.
The data model of XGDBench is a simplified version of the Multiplicative Attribute Graph (MAG)~\cite{Kim2010} model, a synthetic graph model for attribute graphs which models the interactions between the network structure and the node attributes.
The generated graphs are thus in MAG format, with power-law degree distribution closely simulating real-world social networks.
The simplified MAG algorithm accepts the number of vertices of the generated graph, the number of attributes per vertex, a threshold value for random initialization of attributes, an edge affinity threshold value that determines whether there is an edge between two vertices, and an affinity matrix. It has been proven that MAG generates graphs with both analytically tractable and statistically interesting properties. A multi-threaded version of the graph generator that generates large graphs on multi-core systems faster was implemented too.


\paragraph{gMark}  gMark~\cite{gMark} is a schema-driven, domain-independent and query language-independent graph instance and query workload generator.  It leverages a schema definition,
called a \emph{graph configuration}, which includes the enumeration of predicates (i.e., edge labels) and node types (i.e., node labels) occurring in the data, along with their properties in generated instances (occurrence constraints, degree distribution, etc.). \emph{Query workload configuration}  describes parameters of the queries to be generated (e.g., number of queries, arity, shape, selectivity etc.). The authors prove that given a graph configuration $G$, deciding whether there exists a graph satisfying $G$ is NP-complete. And, that given a query workload configuration $Q$, deciding
whether there exists a query workload satisfying $Q$ is NP-complete. Hence, gMark follows a heuristic strategy in the generation -- it attempts to achieve the exact values of the parameters and it may decide to relax some of them in order to obtain linear running time. gMark generates graphs under the form of N-triples and query workloads in four concrete syntaxes, including Cypher\footnote{\url{https://neo4j.com/developer/cypher-query-language/}}, SPARQL, SQL and LogicQL.

\paragraph{GraphGen}  GraphAware GraphGen\footnote{\url{http://graphgen.graphaware.com/}} is a graph generation engine based on Neo4j's\footnote{\url{https://neo4j.com/}} query language Cypher~\cite{GraphGen}.  It creates nodes and relationships based on a schema definition expressed in Cypher, and it can also generate property values on both
nodes and edges. As such, GraphGen is a precursor of property graphs generators. The resulting graph can be exported to several formats (namely GraphJson\footnote{\url{https://github.com/GraphAlchemist/GraphJSON/wiki/GraphJSON}} and CypherQueries) or loaded directly to a DBMS. However, it is probably not maintained anymore. 