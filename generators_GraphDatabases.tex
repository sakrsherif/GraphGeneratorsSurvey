\subsection{Graph Databases}
\label{sec:generators_GraphDatabases}

Currently there exists a number of papers which compare the efficiency of graph databases with regards to distinct use cases, such as  the community detection problem~\cite{Beis2015}, social tagging systems~\cite{Giatsoglou2011}, graph traversal~\cite{Ciglan:2012:BTO:2374486.2375242}, graph pattern matching~\cite{Pobiedina2014}, data provenance~\cite{Vicknair:2010:CGD:1900008.1900067}, or even several distinct use cases~\cite{Grossniklaus2013Towar-24253}. However, the number of graph data generators and benchmarks that have been designed specifically for graph data management systems (Graph DBMS)  is relatively small. Either a general graph generator is used for benchmarking graph databases, such as, e.g., the HPC Scalable Graph Analysis Benchmark~\cite{Dominguez-Sal:2010:SGD:1927585.1927590} or the graph DBMS benchmarking tools are designed while having in mind a more general scope. Hence it is questionable whether a benchmark  that is targeted specifically for graph databases is necessary. \cite{Dominguez-Sal:2010:DDG:1946050.1946053} discussed this question and related topics. On the basis of a review of applications of graph databases (namely, social network analysis,  genetic interactions and recommendation systems), the authors analyzed and discussed the features of the graphs for these types of applications and how such features can affect the benchmarking process, various types of operations used in these applications and the characteristics of the evaluation setup of the benchmark. In this section, we focus on graph data generators and benchmarks that have been primarily targeting graph DBMSs.


\paragraph{XGDBench} XGDBench~\cite{Dayarathna:2014:GDB:2676904.2676939} is an extensible  benchmarking platform for graph databases used in cloud-based systems. Its intent is to automate
the process of graph database benchmarking in the cloud by focusing on the domain social networking services. It extends the Yahoo! Cloud Multiplicative Attribute (MAG) Graph Serving Benchmark (YCSB)~\cite{Cooper:2010:BCS:1807128.1807152} and provides a set of standard workloads representing various performance issues. In particular, the workload of XGDBench involves basic operations such as read / insert / update / delete an attribute, loading of the list of neighbours and BFS traversal. Using the generators, 7 workloads are created, such as update heavy, read mostly, short range scan, traverse heavy etc.
The data model of XGDBench is a simplified version of the Multiplicative Attribute Graph (MAG)~\cite{Kim2010} model, a synthetic graph model which models the interactions between node attributes and  graph structure.
The generated graphs are thus in MAG format, with power-law degree distribution closely simulating real-world social networks.
The simplified MAG algorithm accepts the required number of nodes, the number of attributes per each node, a threshold value for random attribute initialization, an edge affinity threshold determining existence of an edge between two nodes, and an affinity matrix. \iffalse It has been proven that MAG generates graphs with both analytically tractable and statistically interesting properties.\fi
Large graphs can be generated on multi-core systems by a multi-threaded version of the  generator.


\paragraph{gMark}  gMark~\cite{gMark} is a schema-driven and domain-agnostic generator of both graph instances and graph query workloads. It can generate instances under the form of N-triples and queries in various concrete query languages, including OpenCypher\footnote{\url{https://neo4j.com/developer/cypher-query-language/}}, recursive SQL, SPARQL and LogicQL. In gMark, it is possible to specify a \emph{graph configuration} involving the admitted edge predicates and node labels occurring in the graph instance along with additional parameters such as degree distribution, occurrence constraints, etc. The \emph{Query workload configuration} describes parameters of the query workload to be generated, by including the number of queries, arity, shape and selectivity of the queries.
The problem of deciding whether there exists a graph that satisfies a defined graph specification $G$ is NP-complete. The same applies to the problem of deciding
whether there exists a query workload compliant with a given query workload configuration $Q$. In view of this, gMark adopts a best effort approach in which the
parameters specified in the configuration files are attained in a relaxed fashion in order to achieve linear running time whenever possible.

%The authors prove that deciding whether there exists a graph satisfying a given graph configuration $G$ is NP-complete. And, similarly, deciding
%whether there exists a query workload satisfying a given query workload configuration $Q$ is also NP-complete. Hence, gMark generating is based on a heuristic strategy: it tries to achieve the exact values of the given parameters, however, in order to obtain linear running time it may decide to relax some. gMark generates graphs under the form of N-triples and query workloads in four concrete syntaxes, including Cypher\footnote{\url{https://neo4j.com/developer/cypher-query-language/}}, SPARQL, SQL and LogicQL.

\paragraph{GraphGen}  GraphAware GraphGen\footnote{\url{http://graphgen.graphaware.com/}} is a graph generation engine based on Neo4j's\footnote{\url{https://neo4j.com/}} query language OpenCypher~\cite{GraphGen}.  It creates nodes and relationships based on a schema definition expressed in Cypher, and it can also generate property values on both
nodes and edges. As such, GraphGen is a precursor of property graphs generators. The resulting graph can be exported to several formats (namely GraphJson\footnote{\url{https://github.com/GraphAlchemist/GraphJSON/wiki/GraphJSON}} and CypherQueries) or loaded directly to a DBMS. However, it is very likely that it is not maintained anymore due to the lack of available recent commits.

\paragraph{Strengths and Weaknesses of Graph Database Generators}
The graph DBMS generators discussed in this section have in common the fact that they can generate semantically rich labeled graphs with properties (ranging from properties values in GraphGen to MAG structures in XGDBench). They are also capable of generating graph instances and query workloads in
concrete syntaxes (among which OpenCypher in GraphGen and gMark) and one of them (XGDBench) can also handle update operations on both graph structure and content. However, more comprehensive graph DBMS generators that also produce data manipulation operations (such as updates for graph databases) are urgently needed. Additionally, none of these generators is enabled to work on corresponding query languages for property graphs, such as the newly emerging standard GQL~\cite{gql-2018} and G-Core~\cite{AnglesABBFGLPPS18}. Hence, a full-fledged graph DBMS generator for property graphs and property graph query workloads~\cite{BFVY18} is still missing and there exists an interesting opportunity to build such a generator in the near future.

Another apparent inconvenience is represented by the fact that explicit correlations among graph elements cannot be encoded for instance in gMark or GraphGen, whereas they could be fruitful in order to reproduce the behavior of real-world graphs in which attribute values are correlated one with another. On the other hand, social network and Linked Data generators that support correlations (as highlighted in Section \ref{sec:generators_socialnetworks} and Section \ref{sec:generators_LinkedData}) typically exhibit a fixed schema and are not not necessarily multi-domain as are some of the graph DBMS generators discussed in this section (namely GraphGen and gMark).

