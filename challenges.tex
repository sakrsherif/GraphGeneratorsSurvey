\section{Challenges and Open Problems}
\label{sec:challenges}

In this section, we discuss several of the open challenges in large scale graph
generation.

\subsection{Single- vs. multi-domain}

Most of existing graph generators generate graphs that are either not labeled or
are specific to a given domain (e.g.  Social Networks). Graphs from different
domains have different schemas, structural characteristics, property
distributions, etc. which might have an impact on the performance of the
application under test. Thus, graph processing engine developers are asking for
generators or tools to flexibly and holistically generate multi-domain graphs, allowing to configure aspects
such as size, schemata, data distributions and other structural
characteristics such as degree distributions, clustering coefficients, and
so on. 


\subsection{Simple Usage, Simple Parameters}
The proposal of a data generator (not necessarily for graph data) has to face an
important schism. On one hand, it must provide the user with as
many parameters as possible in order to enable him/her to generate
arbitrary data.
This approach seems to be reasonable, but it entails a shortcoming due to
the fact that ordinary users are
unwilling to use complex benchmarking tools. This observation can be
seen, for example, in the case of XML benchmarks -- even though there exist
robust and complex data generators (such as
ToXGene~\cite{conf/webdb/BarbosaMKL02}, which supports specification of
structural aspects, value distributions, references etc.), the most popular
benchmarking tool is XMark~\cite{Schmidt:2002:XBX:1287369.1287455}, which models
a single use case and enables to specify just the size of the data. Hence, the
other extreme is to provide a simple data generator which does not require any
complex settings and thus guarantees a simple and fast benchmarking process.

Considering the complex structure of graph data and the variety of applications
requiring highly specific types of graphs, the latter solution is difficult to
implement. A reasonable compromise can be found in a data generator which is
provided with sample graph data and is capable of automatic analysis of its
structural and value features in order to learn the complex parameters.

\subsection{Evolving Graph Data}
As user requirements as well as environments change, most of the existing
applications naturally evolve over time, at least to some extent. This evolution
usually influences the structure of the data and consequently all the related
parts of the application (i.e., storage strategies, operations, indexes etc.).
The respective data generator should hence be able to simulate such a growth
and/or change in structure.

In some graph applications, such as, e.g., social networks, the evolution of the
data is a significant aspect, especially in the activity graphs, that has been
studied
extensively~\cite{doreian1997evolution,Kumar:2006:SEO:1150402.1150476,Hellmann2014583,wang2013,Kossinets88,Viswanath:2009:EUI:1592665.1592675}.
A related problem is \emph{data versioning} and respective ability to query
across multiple versions of data or to carry out general analysis. 
%Considering graph
%data this problem is also common, for example  in the area of Linked
This problem has been investigated for instance within the domain of Linked
Open Data~\cite{DBLP:conf/semweb/Papakonstantinou16,DBLP:conf/esws/MeimarisP16,fernandez2015towards,fernandez2015bear}.

As shown in~\cite{Leskovec:2005:RMT:2101235.2101254,Leskovec:2005:GOT:1081870.1081893},
evolving graphs have further specific features. For example, some graphs grow
over time according to a \emph{densification power law} which means that real
graphs tend to sprout many more edges than nodes, and thus are densifying as
they grow. Also the effective diameter of graphs tends to shrink or stabilize as
the graph grows with time.

%\paragraph{} Following the same recursion idea,
%paper~\cite{Leskovec:2005:RMT:2101235.2101254} uses Kronecker multiplication to
%generate self-similar graphs. The network starts with an initial graph G1 that
%contains $N_1$ nodes and $E_1$ edges. Using matrix recursion, larger successive
%graphs $G_2, G_3, ... G_n$ are generated. The $k$-th graph $G_k$ contains $N_k
%= N^k_1$ nodes. Many graphs often densify over time, exhibiting a growth in the
%number of edges that is superlinear to the number of nodes. Kronecker
%multiplication produces graphs with a fixed diameter and a densification power
%law degree distribution with exponent $k = log(E_1)/log(N_1)$. The graph
%generation process introduces a staircase effect in the nodes' degrees, and
%each community consists of smaller nested communities that are formed through
%expansion and recursion.


\subsection{Multi-model Data}
With the dawn of Big Data and especially its variety aspect, new types of
database management systems have emerged. One of the most interesting ones
are the so-called \emph{multi-model databases} that enable to store and
thus
query across structurally different data. There exist various types of
multi-model systems combining  distinct subsets of Big Data structures,
such as for instance systems that combine graph data with other data models.
For example, OrientDB\footnote{\url{http://orientdb.com/orientdb/}} which was
implemented on the basis of an object DBMS currently supports graph, document,
key/value, and object models. Such type of DBMSs also needs a specific
benchmarking data generator that would enable
to test new features and analyze efficiency of operations. However, since the
multi-model systems are in the context of Big Data rather new, there exist only
a few benchmarks targeting multi-model DBMSs (such as
Bigframe~\cite{journals/pvldb/KunjirKB14} or UniBench~\cite{conf/cidr/lu17})
with limited capabilities.
Another interesting approach to multi-model data is to adopt a unifying
expressive graph data model, known as property graph data
model~\cite{BFVY18}. Such a model allows to specify multi-edges and list of
properties for the nodes. Synthetic graph generators for property graphs and its
companion standard graph query language~\cite{Angles18,AnglesABBFGLPPS18} are also needed in order to boost
their availability and adoption for different communities.  

\subsection{Large scale graphs with realistic structure}

Most of existing graph generators aiming at generating large graphs with realistic
structural characteristics focus principally on reproducing the degree
distribution and the clustering
coefficient~\cite{kolda2014scalable,edunov2016darwini}. However, there are other
structural characteristics one might be interested in reproducing for a large
graph, such the diameter, the size of the largest connected component, or the
hierarchical community structure. Graph practitioners are highly interested in knowing
how other high-level structural characteristics affect the performance of graph
queries and graph algorithms. Hence, a compelling open challenge consists
of creating
graph generators that allow to reproduce diverse structural characteristics
of the graphs along with large scale sizes. 


\subsection{Machine Learning based graph generation}

With the advent of neural networks and specially generative adversarial networks
(GANs)~\cite{goodfellow2014generative}, several researchers have started to
explore their application to generate graphs. This is the case of
~\cite{kipf2016variational,grover2018graphite,simonovsky2018graphvae,li2018learning,you2018graphrnn},
which present several generative models to generate realistic graphs.  Such
techniques still suffer from several problems. For instance, some of them are
limited to learn from a single
graph~\cite{kipf2016variational,grover2018graphite} or generate small
graphs~\cite{simonovsky2018graphvae,li2018learning,you2018graphrnn}. The
technique proposed in~\cite{you2018graphrnn} is capable of generating graphs
with complex edge dependencies (e.g. community structure) and is not restricted
to graphs of a fixed size. However, there is still in general several open
challenges, including the capability of learning from and generating large graphs comparable
in size to those typically used for benchmarking, and robust generation
techniques with structural guarantees (e.g. degree distribution, clustering
coefficient, etc.).


\subsection{Generating noisy graphs and graphs with anomalies}
Injecting noise and/or anomalies and errors into graphs is crucial for
testing both machine learning algorithms working on this complex data and 
data quality techniques aiming at detecting anomalies and repairing graph
data. 

Concerning the former, analyzing and labelling structural networks is
deemed to be more difficult for graph datasets in the presence of noise. 
Since denoising graph data is difficult to achieve, several machine learning
techniques have been adapted to work with noise (i.e. mislabeled
samples) or outliers, such as 
imbalanced graph classification \cite{PanZ13} and 
binary graph classification with positive and negative weights \cite{CheungSML16}.  
Synthetic graph generators that take into account noisy and missing data 
have been studied in \cite{NamataG10}, where graph identification is presented in
order to  model the inference of a cleaned output network from a
noisy input graph.
Concerning the latter, data quality techniques handling graph data are recently considering ad-hoc
generation of graph data and graph quality rules in order to assess the
effectiveness of error detection and data repairing algorithms \cite{FanWX16a,AriouaB18}. The
corresponding graph quality rules are typically handcrafted by domain
experts, whereas an automatic generation of such rules along with the graph
data generation in tandem would be an interesting future challenge for the
community. 

\subsection{Streaming Graph Generators}
Stream computing is a new paradigm that is necessitated by various modern data generation scenarios such as the ubiquity of mobile devices, location services, 
sensor pervasiveness and emerging Internet-of-Things (IoT) applications. These applications generate the data with \emph{high Velocity}, one of the main 3V characteristics of big data applications~\cite{sakr2016big}. In most of these high speed data generation scenarios, various objects are connected together with different relations and data exchanges  in a graph-structured manner. The Semantic Web community has been considering the aspect of implementing streaming RDF generator and benchmarks, however, there is still a clear lack on considering this aspect on other important and timely domains such as IoT. Thus, there is a crucial need to tackle this aspect. In addition, graph streaming generators should  consider some specific aspects for the stream processing domains such as the out-of-order handling (late arrivals)~\cite{li2008out} and the variety in the schemas and formats of the different data streaming sources. It is also recommended for the streaming graph generators to support the distributed environment as this is the most common scenario for such type of applications. 
